#!/usr/bin/env bash
#
# PostgreSQL Backup Script
# Performs automated PostgreSQL backups with compression and validation
#

set -euo pipefail

# Configuration
BACKUP_DIR="{{ backup_root_dir }}/postgres"
STAGING_DIR="{{ backup_staging_dir }}/postgres"
LOG_FILE="{{ backup_log_dir }}/postgres-backup.log"
CONTAINER_NAME="shared-postgres"
RESTIC_REPOSITORY="${RESTIC_REPOSITORY:-{{ restic_repository_nas }}}"
RESTIC_PASSWORD_FILE="${RESTIC_PASSWORD_FILE:-{{ backup_config_dir }}/restic-password}"

# Database configuration
DB_HOST="127.0.0.1"
DB_PORT="5432"
DB_USER="{{ psql_user }}"
PGPASSWORD="{{ psql_pass }}"
export PGPASSWORD

# Backup settings
BACKUP_RETENTION_DAYS={{ backup_retention.daily }}
COMPRESSION_LEVEL=9
TEST_DB_NAME="backup_test_$(date +%s)"

# Logging function
log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') [postgres-backup] $1" | tee -a "$LOG_FILE"
}

# Error handler
error_exit() {
    log "ERROR: $1"
    cleanup_test_db
    exit 1
}

# Cleanup function for test database
cleanup_test_db() {
    if [ -n "${TEST_DB_NAME:-}" ]; then
        log "Cleaning up test database: $TEST_DB_NAME"
        dropdb -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" --if-exists "$TEST_DB_NAME" 2>/dev/null || true
    fi
}

# Check PostgreSQL container health
check_postgres_health() {
    log "Checking PostgreSQL container health..."

    # Check if container is running
    if ! podman ps --format "{{.Names}}" | grep -q "^$CONTAINER_NAME$"; then
        error_exit "PostgreSQL container $CONTAINER_NAME is not running"
    fi

    # Check if PostgreSQL is ready
    if ! podman exec "$CONTAINER_NAME" pg_isready -U "$DB_USER" -d postgres >/dev/null 2>&1; then
        error_exit "PostgreSQL is not ready to accept connections"
    fi

    # Test connection
    if ! psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d postgres -c "SELECT 1;" >/dev/null 2>&1; then
        error_exit "Cannot connect to PostgreSQL database"
    fi

    log "PostgreSQL health check passed"
}

# Get list of databases
get_databases() {
    log "Retrieving database list..."

    local databases
    databases=$(psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d postgres -t -c "SELECT datname FROM pg_database WHERE datistemplate = false AND datname != 'postgres';" | grep -v "^$" | tr -d ' ')

    if [ -z "$databases" ]; then
        log "No user databases found, backing up postgres database only"
        echo "postgres"
    else
        log "Found databases: $(echo "$databases" | tr '\n' ' ')"
        echo "$databases"
    fi
}

# Setup directories
setup_directories() {
    log "Setting up backup directories..."

    mkdir -p "$BACKUP_DIR"
    mkdir -p "$STAGING_DIR"

    # Clean old staging files
    find "$STAGING_DIR" -type f -name "*.sql.gz" -mtime +1 -delete 2>/dev/null || true
    find "$STAGING_DIR" -type f -name "*.sql" -mtime +1 -delete 2>/dev/null || true

    log "Directories prepared"
}

# Create database backup
backup_database() {
    local database="$1"
    local timestamp="$2"
    local backup_file="$STAGING_DIR/${database}_${timestamp}.sql"
    local compressed_file="${backup_file}.gz"

    log "Backing up database: $database"

    # Create backup using pg_dump
    if ! pg_dump -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$database" \
        --verbose --no-password --format=plain \
        --no-owner --no-privileges \
        --compress=0 \
        > "$backup_file" 2>/dev/null; then
        error_exit "Failed to create backup for database: $database"
    fi

    # Verify backup file exists and has content
    if [ ! -f "$backup_file" ] || [ ! -s "$backup_file" ]; then
        error_exit "Backup file for $database is empty or missing"
    fi

    # Compress the backup
    log "Compressing backup for database: $database"
    if ! gzip -"$COMPRESSION_LEVEL" "$backup_file"; then
        error_exit "Failed to compress backup for database: $database"
    fi

    # Calculate compression ratio
    local original_size compressed_size compression_ratio
    original_size=$(stat -c%s "$backup_file" 2>/dev/null || echo "0")
    compressed_size=$(stat -c%s "$compressed_file" 2>/dev/null || echo "0")

    if [ "$original_size" -gt 0 ]; then
        compression_ratio=$(( (original_size - compressed_size) * 100 / original_size ))
        log "Compression ratio for $database: ${compression_ratio}% (${original_size} -> ${compressed_size} bytes)"

        # Check if compression meets requirement (>70%)
        if [ "$compression_ratio" -lt 70 ]; then
            log "WARNING: Compression ratio for $database is ${compression_ratio}%, below 70% target"
        fi
    fi

    echo "$compressed_file"
}

# Test restore validation
test_restore() {
    local backup_file="$1"
    local database_name="$2"

    log "Testing restore validation for database: $database_name"

    # Create test database
    if ! createdb -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" "$TEST_DB_NAME" 2>/dev/null; then
        error_exit "Failed to create test database: $TEST_DB_NAME"
    fi

    # Restore backup to test database
    if ! gunzip -c "$backup_file" | psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$TEST_DB_NAME" >/dev/null 2>&1; then
        error_exit "Failed to restore backup to test database"
    fi

    # Verify restore by checking if we can query the database
    local table_count
    table_count=$(psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$TEST_DB_NAME" -t -c "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public';" 2>/dev/null | tr -d ' ')

    if [ -z "$table_count" ]; then
        error_exit "Failed to query restored database"
    fi

    log "Restore validation passed for $database_name (tables: $table_count)"

    # Cleanup test database
    cleanup_test_db
}

# Upload to restic repository
upload_to_restic() {
    local backup_files="$1"

    log "Uploading PostgreSQL backups to restic repository..."

    # Verify restic repository exists
    if ! restic -r "$RESTIC_REPOSITORY" snapshots >/dev/null 2>&1; then
        log "Initializing restic repository..."
        if ! restic -r "$RESTIC_REPOSITORY" init; then
            error_exit "Failed to initialize restic repository"
        fi
    fi

    # Create backup with metadata
    if ! restic -r "$RESTIC_REPOSITORY" backup $backup_files \
        --tag postgres \
        --tag "$(date '+%Y-%m-%d')" \
        --host "$(hostname)" \
        --time "$(date -Iseconds)"; then
        error_exit "Failed to upload PostgreSQL backups to restic repository"
    fi

    log "PostgreSQL backups uploaded to restic repository successfully"
}

# Cleanup old local backups
cleanup_old_backups() {
    log "Cleaning up old local backups..."

    # Remove local backups older than retention period
    find "$BACKUP_DIR" -name "*.sql.gz" -mtime +$BACKUP_RETENTION_DAYS -delete 2>/dev/null || true
    find "$STAGING_DIR" -name "*.sql.gz" -mtime +1 -delete 2>/dev/null || true

    log "Old backup cleanup completed"
}

# Verify backup in restic
verify_backup() {
    log "Verifying PostgreSQL backup in restic repository..."

    # Check latest snapshot
    local latest_snapshot
    latest_snapshot=$(restic -r "$RESTIC_REPOSITORY" snapshots --tag postgres --last 1 --json 2>/dev/null | jq -r '.[0].short_id // empty')

    if [ -z "$latest_snapshot" ]; then
        error_exit "No PostgreSQL backup found in restic repository"
    fi

    # Verify snapshot integrity
    if ! restic -r "$RESTIC_REPOSITORY" check --read-data "$latest_snapshot" >/dev/null 2>&1; then
        error_exit "PostgreSQL backup verification failed in restic repository"
    fi

    log "PostgreSQL backup verification passed (snapshot: $latest_snapshot)"
}

# Main backup process
main() {
    log "Starting PostgreSQL backup process..."

    # Setup trap for cleanup
    trap cleanup_test_db EXIT

    # Pre-backup checks
    check_postgres_health
    setup_directories

    # Get databases to backup
    local databases
    databases=$(get_databases)

    # Create backups
    local timestamp backup_files
    timestamp=$(date '+%Y%m%d_%H%M%S')
    backup_files=""

    for database in $databases; do
        local backup_file
        backup_file=$(backup_database "$database" "$timestamp")

        # Test restore validation
        test_restore "$backup_file" "$database"

        backup_files="$backup_files $backup_file"
    done

    # Upload to restic
    upload_to_restic "$backup_files"

    # Post-backup tasks
    verify_backup
    cleanup_old_backups

    log "PostgreSQL backup completed successfully"
}

# Execute main function
main "$@"
