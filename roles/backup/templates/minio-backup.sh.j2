#!/usr/bin/env bash
#
# MinIO Backup and Restore Script
# Performs comprehensive MinIO backups including data, configurations, and IAM settings
# Supports full disaster recovery and restoration to new instances
#

set -euo pipefail

# Configuration
BACKUP_DIR="{{ backup_root_dir }}/minio"
STAGING_DIR="{{ backup_staging_dir }}/minio"
LOG_FILE="{{ backup_log_dir }}/minio-backup.log"
CONTAINER_NAME="shared-minio"
RESTIC_REPOSITORY="${RESTIC_REPOSITORY:-{{ restic_repository_nas }}}"
RESTIC_PASSWORD_FILE="${RESTIC_PASSWORD_FILE:-{{ backup_config_dir }}/restic-password}"

# MinIO configuration
MINIO_ENDPOINT="http://127.0.0.1:9000"
MINIO_ALIAS="backup-local"
MINIO_ACCESS_KEY="{{ minio_user }}"
MINIO_SECRET_KEY="{{ minio_pass }}"

# MC client configuration
MC_CONFIG_DIR="{{ backup_config_dir }}/mc"
MC_BANDWIDTH_LIMIT="{{ backup_bandwidth_limit }}"

# Backup settings
BACKUP_RETENTION_DAYS={{ backup_retention.daily }}
BACKUP_ARCHIVE_NAME="minio_backup_$(date +%Y%m%d_%H%M%S).tar.gz"

# Restore settings
RESTORE_MINIO_ENDPOINT="${RESTORE_MINIO_ENDPOINT:-http://127.0.0.1:9000}"
RESTORE_MINIO_ALIAS="${RESTORE_MINIO_ALIAS:-restore-local}"
RESTORE_MINIO_ACCESS_KEY="${RESTORE_MINIO_ACCESS_KEY:-}"
RESTORE_MINIO_SECRET_KEY="${RESTORE_MINIO_SECRET_KEY:-}"

# Operation mode
OPERATION="${1:-backup}"  # backup, restore, or setup-replication

# Exclusion patterns
EXCLUSION_PATTERNS=(
    "*.tmp"
    "*.temp"
    "*/.DS_Store"
    "*/Thumbs.db"
    "*/.git/*"
    "*/node_modules/*"
    "*/__pycache__/*"
    "*.log"
    "*.cache"
)

# Logging function
log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') [minio-${OPERATION}] $1" | tee -a "$LOG_FILE"
}

# Error handler
error_exit() {
    log "ERROR: $1"
    exit 1
}

# Display usage information
show_usage() {
    cat << EOF
Usage: $0 [OPERATION] [OPTIONS]

OPERATIONS:
    backup              Perform full MinIO backup (default)
    restore             Restore MinIO from backup
    setup-replication   Setup replication to secondary instance
    list-backups       List available backups in restic repository
    verify-backup      Verify specific backup integrity

RESTORE OPTIONS:
    --snapshot-id ID   Specific restic snapshot to restore (optional)
    --restore-endpoint URL  Target MinIO endpoint for restoration
    --restore-access-key KEY   Access key for target MinIO
    --restore-secret-key KEY   Secret key for target MinIO

EXAMPLES:
    $0 backup                           # Perform backup
    $0 restore                          # Restore latest backup
    $0 restore --snapshot-id abc123     # Restore specific snapshot
    $0 list-backups                     # List available backups
    $0 setup-replication               # Setup replication

ENVIRONMENT VARIABLES:
    RESTORE_MINIO_ENDPOINT     Target MinIO endpoint for restore
    RESTORE_MINIO_ACCESS_KEY   Access key for target MinIO  
    RESTORE_MINIO_SECRET_KEY   Secret key for target MinIO
EOF
}

# Parse command line arguments
parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --snapshot-id)
                RESTORE_SNAPSHOT_ID="$2"
                shift 2
                ;;
            --restore-endpoint)
                RESTORE_MINIO_ENDPOINT="$2"
                shift 2
                ;;
            --restore-access-key)
                RESTORE_MINIO_ACCESS_KEY="$2"
                shift 2
                ;;
            --restore-secret-key)
                RESTORE_MINIO_SECRET_KEY="$2"
                shift 2
                ;;
            --help|-h)
                show_usage
                exit 0
                ;;
            *)
                log "Unknown option: $1"
                show_usage
                exit 1
                ;;
        esac
    done
}

# Check MinIO container health
check_minio_health() {
    local endpoint="${1:-$MINIO_ENDPOINT}"
    local container="${2:-$CONTAINER_NAME}"
    
    log "Checking MinIO health at $endpoint..."

    # Check if container is running (if specified)
    if [ -n "$container" ] && [ "$container" != "none" ]; then
        if ! podman ps --format "{{.Names}}" | grep -q "^$container$"; then
            error_exit "MinIO container $container is not running"
        fi
    fi

    # Check MinIO health endpoint
    if ! curl -f "$endpoint/minio/health/live" >/dev/null 2>&1; then
        error_exit "MinIO health check failed for $endpoint"
    fi

    log "MinIO health check passed for $endpoint"
}

# Setup MC client configuration
setup_mc_config() {
    log "Setting up MC client configuration..."

    mkdir -p "$MC_CONFIG_DIR"
    export MC_CONFIG_DIR="$MC_CONFIG_DIR"

    if [ -n "$MC_BANDWIDTH_LIMIT" ]; then
        log "Setting bandwidth limit to: $MC_BANDWIDTH_LIMIT"
    fi

    log "MC client configuration completed"
}

# Configure MC alias
configure_mc_alias() {
    local alias="$1"
    local endpoint="$2"
    local access_key="$3"
    local secret_key="$4"
    
    log "Configuring MC alias: $alias for $endpoint..."

    # Remove existing alias if present
    mc alias remove "$alias" --config-dir="$MC_CONFIG_DIR" 2>/dev/null || true

    # Set new alias
    if ! mc alias set "$alias" "$endpoint" "$access_key" "$secret_key" --config-dir="$MC_CONFIG_DIR"; then
        error_exit "Failed to configure MC alias: $alias"
    fi

    # Test connection
    if ! mc admin info "$alias" --config-dir="$MC_CONFIG_DIR" >/dev/null 2>&1; then
        error_exit "Failed to connect to MinIO using alias: $alias"
    fi

    log "MC alias '$alias' configured successfully"
}

# Get list of buckets
get_buckets() {
    local alias="$1"
    log "Retrieving bucket list from $alias..."

    local buckets
    buckets=$(mc ls "$alias" --config-dir="$MC_CONFIG_DIR" 2>/dev/null | awk '{print $5}' | grep -v "^$" || true)

    if [ -z "$buckets" ]; then
        log "No buckets found in $alias"
        return 0
    fi

    log "Found buckets: $(echo "$buckets" | tr '\n' ' ')"
    echo "$buckets"
}

# Backup bucket policies and configurations
backup_bucket_configs() {
    local alias="$1"
    local config_dir="$STAGING_DIR/configs"
    
    log "Backing up bucket configurations..."
    mkdir -p "$config_dir"

    local buckets
    buckets=$(get_buckets "$alias")
    
    if [ -n "$buckets" ]; then
        for bucket in $buckets; do
            log "Backing up configuration for bucket: $bucket"
            
            # Backup bucket policy
            mc admin policy info "$alias" --config-dir="$MC_CONFIG_DIR" "$bucket" > "$config_dir/${bucket}_policy.json" 2>/dev/null || echo "null" > "$config_dir/${bucket}_policy.json"
            
            # Backup bucket notification configuration
            mc event list "$alias/$bucket" --config-dir="$MC_CONFIG_DIR" > "$config_dir/${bucket}_notifications.json" 2>/dev/null || echo "[]" > "$config_dir/${bucket}_notifications.json"
            
            # Backup bucket encryption settings
            mc encrypt info "$alias/$bucket" --config-dir="$MC_CONFIG_DIR" > "$config_dir/${bucket}_encryption.json" 2>/dev/null || echo "null" > "$config_dir/${bucket}_encryption.json"
            
            # Backup bucket versioning status
            mc version info "$alias/$bucket" --config-dir="$MC_CONFIG_DIR" > "$config_dir/${bucket}_versioning.txt" 2>/dev/null || echo "Suspended" > "$config_dir/${bucket}_versioning.txt"
            
            # Backup bucket lifecycle rules
            mc ilm export "$alias/$bucket" --config-dir="$MC_CONFIG_DIR" > "$config_dir/${bucket}_lifecycle.json" 2>/dev/null || echo "null" > "$config_dir/${bucket}_lifecycle.json"
        done
    fi

    log "Bucket configurations backed up"
}

# Backup IAM configurations
backup_iam_configs() {
    local alias="$1"
    local iam_dir="$STAGING_DIR/iam"
    
    log "Backing up IAM configurations..."
    mkdir -p "$iam_dir"

    # Backup service accounts
    mc admin user svcacct list "$alias" --config-dir="$MC_CONFIG_DIR" > "$iam_dir/service_accounts.json" 2>/dev/null || echo "[]" > "$iam_dir/service_accounts.json"
    
    # Backup users list
    mc admin user list "$alias" --config-dir="$MC_CONFIG_DIR" > "$iam_dir/users.json" 2>/dev/null || echo "[]" > "$iam_dir/users.json"
    
    # Backup policies
    mc admin policy list "$alias" --config-dir="$MC_CONFIG_DIR" > "$iam_dir/policies.json" 2>/dev/null || echo "[]" > "$iam_dir/policies.json"
    
    # Backup groups
    mc admin group list "$alias" --config-dir="$MC_CONFIG_DIR" > "$iam_dir/groups.json" 2>/dev/null || echo "[]" > "$iam_dir/groups.json"

    log "IAM configurations backed up"
}

# Create backup metadata
create_backup_metadata() {
    local metadata_file="$STAGING_DIR/backup_metadata.json"
    
    log "Creating backup metadata..."
    
    cat > "$metadata_file" << EOF
{
    "backup_timestamp": "$(date -Iseconds)",
    "backup_version": "2.0",
    "source_endpoint": "$MINIO_ENDPOINT",
    "hostname": "$(hostname)",
    "minio_version": "$(mc admin info $MINIO_ALIAS --config-dir="$MC_CONFIG_DIR" 2>/dev/null | grep 'Version:' | awk '{print $2}' || echo 'unknown')",
    "total_buckets": $(get_buckets "$MINIO_ALIAS" | wc -l),
    "backup_type": "full",
    "compression": "gzip",
    "includes": {
        "bucket_data": true,
        "bucket_configs": true,
        "iam_settings": true,
        "policies": true
    }
}
EOF

    log "Backup metadata created"
}

# Setup directories
setup_directories() {
    log "Setting up backup directories..."

    mkdir -p "$BACKUP_DIR"
    mkdir -p "$STAGING_DIR"
    mkdir -p "$STAGING_DIR/data"
    mkdir -p "$STAGING_DIR/configs"
    mkdir -p "$STAGING_DIR/iam"

    # Clean old staging files
    find "$STAGING_DIR" -type f -name "*.tar.gz" -mtime +1 -delete 2>/dev/null || true
    find "$STAGING_DIR" -type d -empty -delete 2>/dev/null || true

    log "Directories prepared"
}

# Build exclusion arguments for MC
build_exclusion_args() {
    local exclude_args=""

    for pattern in "${EXCLUSION_PATTERNS[@]}"; do
        exclude_args="$exclude_args --exclude '$pattern'"
    done

    echo "$exclude_args"
}

# Perform incremental backup for a bucket
backup_bucket() {
    local bucket="$1"
    local bucket_staging_dir="$STAGING_DIR/data/$bucket"
    local exclude_args

    log "Starting backup for bucket: $bucket"

    mkdir -p "$bucket_staging_dir"
    exclude_args=$(build_exclusion_args)

    # Perform incremental mirror sync
    log "Syncing bucket $bucket with incremental mirror..."

    local sync_cmd="mc mirror $exclude_args --preserve --overwrite --remove --config-dir='$MC_CONFIG_DIR' '$MINIO_ALIAS/$bucket' '$bucket_staging_dir'"

    if ! eval "$sync_cmd" 2>/dev/null; then
        error_exit "Failed to mirror bucket: $bucket"
    fi

    local object_count
    object_count=$(find "$bucket_staging_dir" -type f | wc -l)
    log "Mirrored $object_count objects from bucket: $bucket"

    echo "$object_count"
}

# Create compressed archive
create_archive() {
    local archive_path="$STAGING_DIR/$BACKUP_ARCHIVE_NAME"

    log "Creating compressed archive: $BACKUP_ARCHIVE_NAME"

    if ! tar -czf "$archive_path" -C "$STAGING_DIR" --exclude="$BACKUP_ARCHIVE_NAME" . 2>/dev/null; then
        error_exit "Failed to create compressed archive"
    fi

    if [ ! -f "$archive_path" ] || [ ! -s "$archive_path" ]; then
        error_exit "Archive file is empty or missing"
    fi

    local archive_size
    archive_size=$(stat -c%s "$archive_path" 2>/dev/null || echo "0")
    log "Archive created successfully: $BACKUP_ARCHIVE_NAME (${archive_size} bytes)"

    echo "$archive_path"
}

# Upload to restic repository
upload_to_restic() {
    local archive_path="$1"

    log "Uploading MinIO backup to restic repository..."

    # Verify restic repository exists
    if ! restic -r "$RESTIC_REPOSITORY" snapshots >/dev/null 2>&1; then
        log "Initializing restic repository..."
        if ! restic -r "$RESTIC_REPOSITORY" init; then
            error_exit "Failed to initialize restic repository"
        fi
    fi

    # Create backup with metadata
    if ! restic -r "$RESTIC_REPOSITORY" backup "$archive_path" \
        --tag minio \
        --tag "$(date '+%Y-%m-%d')" \
        --tag "full-backup" \
        --host "$(hostname)" \
        --time "$(date -Iseconds)"; then
        error_exit "Failed to upload MinIO backup to restic repository"
    fi

    log "MinIO backup uploaded to restic repository successfully"
}

# List available backups
list_backups() {
    log "Listing available MinIO backups..."
    
    if ! restic -r "$RESTIC_REPOSITORY" snapshots --tag minio --json | jq -r '.[] | "\(.time) \(.short_id) \(.hostname) \(.tags | join(","))"' 2>/dev/null; then
        log "No MinIO backups found in repository"
        return 1
    fi
}

# Download and extract backup from restic
download_backup() {
    local snapshot_id="${1:-latest}"
    local extract_dir="$STAGING_DIR/restore"
    
    log "Downloading backup from restic (snapshot: $snapshot_id)..."
    
    mkdir -p "$extract_dir"
    
    # Find the backup file
    local backup_files
    if [ "$snapshot_id" = "latest" ]; then
        backup_files=$(restic -r "$RESTIC_REPOSITORY" ls latest --tag minio | grep "minio_backup_.*\.tar\.gz$" || true)
    else
        backup_files=$(restic -r "$RESTIC_REPOSITORY" ls "$snapshot_id" | grep "minio_backup_.*\.tar\.gz$" || true)
    fi
    
    if [ -z "$backup_files" ]; then
        error_exit "No backup files found in snapshot: $snapshot_id"
    fi
    
    local backup_file
    backup_file=$(echo "$backup_files" | head -n1)
    
    # Restore the backup file
    if [ "$snapshot_id" = "latest" ]; then
        restic -r "$RESTIC_REPOSITORY" restore latest --tag minio --target "$extract_dir" --include "$backup_file"
    else
        restic -r "$RESTIC_REPOSITORY" restore "$snapshot_id" --target "$extract_dir" --include "$backup_file"
    fi
    
    # Extract the archive
    local archive_path="$extract_dir/$backup_file"
    if [ ! -f "$archive_path" ]; then
        error_exit "Downloaded backup file not found: $archive_path"
    fi
    
    log "Extracting backup archive..."
    if ! tar -xzf "$archive_path" -C "$extract_dir"; then
        error_exit "Failed to extract backup archive"
    fi
    
    # Remove the archive file to save space
    rm -f "$archive_path"
    
    log "Backup downloaded and extracted to: $extract_dir"
    echo "$extract_dir"
}

# Restore bucket configurations
restore_bucket_configs() {
    local alias="$1"
    local config_dir="$2/configs"
    
    if [ ! -d "$config_dir" ]; then
        log "No bucket configurations found to restore"
        return 0
    fi
    
    log "Restoring bucket configurations..."
    
    for config_file in "$config_dir"/*_policy.json; do
        if [ -f "$config_file" ]; then
            local bucket
            bucket=$(basename "$config_file" _policy.json)
            
            log "Restoring configuration for bucket: $bucket"
            
            # Restore bucket policy
            if [ -s "$config_file" ] && [ "$(cat "$config_file")" != "null" ]; then
                mc admin policy create "$alias" "${bucket}-policy" "$config_file" --config-dir="$MC_CONFIG_DIR" 2>/dev/null || true
                mc admin policy attach "$alias" "${bucket}-policy" --user "AROAAAA" --config-dir="$MC_CONFIG_DIR" 2>/dev/null || true
            fi
            
            # Restore versioning if configuration exists
            local versioning_file="$config_dir/${bucket}_versioning.txt"
            if [ -f "$versioning_file" ]; then
                local versioning_status
                versioning_status=$(cat "$versioning_file")
                if [ "$versioning_status" = "Enabled" ]; then
                    mc version enable "$alias/$bucket" --config-dir="$MC_CONFIG_DIR" 2>/dev/null || true
                fi
            fi
            
            # Restore lifecycle rules
            local lifecycle_file="$config_dir/${bucket}_lifecycle.json"
            if [ -f "$lifecycle_file" ] && [ "$(cat "$lifecycle_file")" != "null" ]; then
                mc ilm import "$alias/$bucket" < "$lifecycle_file" --config-dir="$MC_CONFIG_DIR" 2>/dev/null || true
            fi
        fi
    done
    
    log "Bucket configurations restored"
}

# Restore IAM configurations  
restore_iam_configs() {
    local alias="$1"
    local iam_dir="$2/iam"
    
    if [ ! -d "$iam_dir" ]; then
        log "No IAM configurations found to restore"
        return 0
    fi
    
    log "Restoring IAM configurations..."
    
    # Note: This is a simplified IAM restore
    # In production, you'd need more sophisticated user/policy restoration
    log "IAM restoration requires manual intervention for security"
    log "IAM backup files available in: $iam_dir"
    
    log "IAM configurations restore completed (manual steps required)"
}

# Restore bucket data
restore_bucket_data() {
    local target_alias="$1"
    local data_dir="$2/data"
    
    if [ ! -d "$data_dir" ]; then
        log "No bucket data found to restore"
        return 0
    fi
    
    log "Restoring bucket data..."
    
    for bucket_dir in "$data_dir"/*; do
        if [ -d "$bucket_dir" ]; then
            local bucket
            bucket=$(basename "$bucket_dir")
            
            log "Restoring data for bucket: $bucket"
            
            # Create bucket if it doesn't exist
            mc mb "$target_alias/$bucket" --config-dir="$MC_CONFIG_DIR" 2>/dev/null || true
            
            # Mirror data to bucket
            local exclude_args
            exclude_args=$(build_exclusion_args)
            local sync_cmd="mc mirror $exclude_args --preserve --overwrite --config-dir='$MC_CONFIG_DIR' '$bucket_dir' '$target_alias/$bucket'"
            
            if ! eval "$sync_cmd"; then
                log "WARNING: Failed to restore some data for bucket: $bucket"
            else
                local object_count
                object_count=$(find "$bucket_dir" -type f | wc -l)
                log "Restored $object_count objects for bucket: $bucket"
            fi
        fi
    done
    
    log "Bucket data restoration completed"
}

# Verify restoration
verify_restoration() {
    local alias="$1"
    local metadata_file="$2/backup_metadata.json"
    
    log "Verifying restoration..."
    
    if [ -f "$metadata_file" ]; then
        local expected_buckets
        expected_buckets=$(jq -r '.total_buckets' "$metadata_file" 2>/dev/null || echo "0")
        
        local actual_buckets
        actual_buckets=$(get_buckets "$alias" | wc -l)
        
        log "Bucket count verification - Expected: $expected_buckets, Actual: $actual_buckets"
        
        if [ "$expected_buckets" -eq "$actual_buckets" ]; then
            log "Restoration verification passed"
        else
            log "WARNING: Bucket count mismatch detected"
        fi
    else
        log "No metadata found for verification"
    fi
}

# Setup replication to secondary instance
setup_replication() {
    local secondary_endpoint="${RESTORE_MINIO_ENDPOINT}"
    local secondary_access_key="${RESTORE_MINIO_ACCESS_KEY}"
    local secondary_secret_key="${RESTORE_MINIO_SECRET_KEY}"
    
    if [ -z "$secondary_endpoint" ] || [ -z "$secondary_access_key" ] || [ -z "$secondary_secret_key" ]; then
        error_exit "Secondary MinIO credentials not provided. Set RESTORE_MINIO_* environment variables."
    fi
    
    log "Setting up replication to secondary MinIO instance..."
    
    # Configure secondary alias
    configure_mc_alias "secondary" "$secondary_endpoint" "$secondary_access_key" "$secondary_secret_key"
    
    # Get buckets from primary
    local buckets
    buckets=$(get_buckets "$MINIO_ALIAS")
    
    if [ -n "$buckets" ]; then
        for bucket in $buckets; do
            log "Setting up replication for bucket: $bucket"
            
            # Create bucket on secondary if it doesn't exist
            mc mb "secondary/$bucket" --config-dir="$MC_CONFIG_DIR" 2>/dev/null || true
            
            # Enable versioning on both buckets
            mc version enable "$MINIO_ALIAS/$bucket" --config-dir="$MC_CONFIG_DIR" 2>/dev/null || true
            mc version enable "secondary/$bucket" --config-dir="$MC_CONFIG_DIR" 2>/dev/null || true
            
            # Setup replication rule
            mc replicate add "$MINIO_ALIAS/$bucket" \
                --remote-bucket "secondary/$bucket" \
                --priority 1 \
                --replicate "delete,delete-marker,existing-objects" \
                --config-dir="$MC_CONFIG_DIR" 2>/dev/null || log "WARNING: Failed to setup replication for $bucket"
        done
    fi
    
    log "Replication setup completed"
}

# Cleanup old local backups
cleanup_old_backups() {
    log "Cleaning up old local backups..."

    find "$BACKUP_DIR" -name "minio_backup_*.tar.gz" -mtime +$BACKUP_RETENTION_DAYS -delete 2>/dev/null || true
    find "$STAGING_DIR" -name "minio_backup_*.tar.gz" -mtime +1 -delete 2>/dev/null || true
    find "$STAGING_DIR" -type d -name "*" -mtime +1 -exec rm -rf {} + 2>/dev/null || true

    log "Old backup cleanup completed"
}

# Main backup process
perform_backup() {
    log "Starting MinIO backup process..."

    # Pre-backup checks
    check_minio_health "$MINIO_ENDPOINT" "$CONTAINER_NAME"
    setup_directories
    setup_mc_config
    configure_mc_alias "$MINIO_ALIAS" "$MINIO_ENDPOINT" "$MINIO_ACCESS_KEY" "$MINIO_SECRET_KEY"

    # Create backup metadata
    create_backup_metadata

    # Backup configurations
    backup_bucket_configs "$MINIO_ALIAS"
    backup_iam_configs "$MINIO_ALIAS"

    # Get buckets to backup
    local buckets
    buckets=$(get_buckets "$MINIO_ALIAS")

    if [ -z "$buckets" ]; then
        log "No buckets to backup, creating empty data marker"
        touch "$STAGING_DIR/data/no-buckets.txt"
    else
        # Backup each bucket
        local total_objects=0
        for bucket in $buckets; do
            local bucket_objects
            bucket_objects=$(backup_bucket "$bucket")
            total_objects=$((total_objects + bucket_objects))
        done

        log "Total objects backed up: $total_objects"
    fi

    # Create archive and upload
    local archive_path
    archive_path=$(create_archive)
    upload_to_restic "$archive_path"

    # Post-backup tasks
    cleanup_old_backups

    log "MinIO backup completed successfully"
}

# Main restore process
perform_restore() {
    local snapshot_id="${RESTORE_SNAPSHOT_ID:-latest}"
    
    if [ -z "$RESTORE_MINIO_ENDPOINT" ] || [ -z "$RESTORE_MINIO_ACCESS_KEY" ] || [ -z "$RESTORE_MINIO_SECRET_KEY" ]; then
        error_exit "Restore credentials not provided. Set RESTORE_MINIO_* environment variables or use command line options."
    fi
    
    log "Starting MinIO restore process (snapshot: $snapshot_id)..."

    # Pre-restore checks
    check_minio_health "$RESTORE_MINIO_ENDPOINT" "none"
    setup_directories
    setup_mc_config
    configure_mc_alias "$RESTORE_MINIO_ALIAS" "$RESTORE_MINIO_ENDPOINT" "$RESTORE_MINIO_ACCESS_KEY" "$RESTORE_MINIO_SECRET_KEY"

    # Download and extract backup
    local restore_dir
    restore_dir=$(download_backup "$snapshot_id")

    # Restore components
    restore_bucket_data "$RESTORE_MINIO_ALIAS" "$restore_dir"
    restore_bucket_configs "$RESTORE_MINIO_ALIAS" "$restore_dir"
    restore_iam_configs "$RESTORE_MINIO_ALIAS" "$restore_dir"

    # Verify restoration
    verify_restoration "$RESTORE_MINIO_ALIAS" "$restore_dir"

    # Cleanup
    rm -rf "$restore_dir"

    log "MinIO restore completed successfully"
}

# Main function
main() {
    # Parse arguments for operations other than backup
    if [ "$OPERATION" != "backup" ]; then
        shift # Remove operation argument
        parse_arguments "$@"
    fi

    case "$OPERATION" in
        backup)
            perform_backup
            ;;
        restore)
            perform_restore
            ;;
        setup-replication)
            setup_mc_config
            configure_mc_alias "$MINIO_ALIAS" "$MINIO_ENDPOINT" "$MINIO_ACCESS_KEY" "$MINIO_SECRET_KEY"
            setup_replication
            ;;
        list-backups)
            list_backups
            ;;
        verify-backup)
            # This would need additional implementation
            log "Backup verification not yet implemented"
            ;;
        --help|-h)
            show_usage
            ;;
        *)
            log "Unknown operation: $OPERATION"
            show_usage
            exit 1
            ;;
    esac
}

# Execute main function
main "$@"
